import { useState, useEffect, useRef } from 'react'
import { config, buildApiUrl, API_ENDPOINTS } from './config.js'

function EventForm() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    phone: '',
    college: '',
    year: ''
  })
  const [isSubmitted, setIsSubmitted] = useState(false)
  const [isProcessing, setIsProcessing] = useState(false)
  const [error, setError] = useState(null)
  const [validationErrors, setValidationErrors] = useState({})
  const [paymentStatus, setPaymentStatus] = useState(null)
  const [registrationData, setRegistrationData] = useState(null)
  const [networkStatus, setNetworkStatus] = useState('checking')
  const [razorpayStatus, setRazorpayStatus] = useState('loading')
  const [retryCount, setRetryCount] = useState(0)
  const [isRetrying, setIsRetrying] = useState(false)
  
  const abortControllerRef = useRef(null)
  const retryTimeoutRef = useRef(null)
  
  // Configuration constants
  const MAX_RETRY_ATTEMPTS = parseInt(import.meta.env.VITE_RETRY_ATTEMPTS) || 3
  const RETRY_DELAY = parseInt(import.meta.env.VITE_RETRY_DELAY) || 2000
  const NETWORK_TIMEOUT = parseInt(import.meta.env.VITE_NETWORK_TIMEOUT) || 10000

  // Enhanced network connectivity check with retries
  const checkNetworkStatus = async (retryAttempt = 0) => {
    try {
      const controller = new AbortController()
      const timeoutId = setTimeout(() => controller.abort(), NETWORK_TIMEOUT)
      
      const response = await fetch(`${config.API_BASE_URL}/api/health`, {
        signal: controller.signal,
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        }
      })
      
      clearTimeout(timeoutId)
      
      if (response.ok) {
        setNetworkStatus('online')
        return true
      } else {
        throw new Error(`Network check failed: ${response.status} ${response.statusText}`)
      }
    } catch (error) {
      console.error(`Network check failed (attempt ${retryAttempt + 1}):`, error)
      
      if (retryAttempt < MAX_RETRY_ATTEMPTS - 1) {
        console.log(`Retrying network check in ${RETRY_DELAY}ms...`)
        await new Promise(resolve => setTimeout(resolve, RETRY_DELAY * (retryAttempt + 1)))
        return await checkNetworkStatus(retryAttempt + 1)
      }
      
      setNetworkStatus('offline')
      return false
    }
  }

  // Check and ensure Razorpay is loaded
  const checkRazorpayStatus = async (retryAttempt = 0) => {
    try {
      if (typeof window.Razorpay !== 'undefined') {
        setRazorpayStatus('loaded')
        return true
      }
      
      // Wait a bit for the script to load
      await new Promise(resolve => setTimeout(resolve, 500))
      
      if (typeof window.Razorpay !== 'undefined') {
        setRazorpayStatus('loaded')
        return true
      }
      
      throw new Error('Razorpay not loaded')
    } catch (error) {
      if (retryAttempt < MAX_RETRY_ATTEMPTS - 1) {
        console.log(`Retrying Razorpay check (attempt ${retryAttempt + 2})...`)
        setRazorpayStatus('retrying')
        await new Promise(resolve => setTimeout(resolve, RETRY_DELAY))
        return await checkRazorpayStatus(retryAttempt + 1)
      }
      
      console.error('Razorpay loading failed after all retries')
      setRazorpayStatus('failed')
      return false
    }
  }

  // Initialize systems on component mount
  useEffect(() => {
    const initializeSystems = async () => {
      // Check network first
      const isOnline = await checkNetworkStatus()
      
      // Check Razorpay loading
      await checkRazorpayStatus()
      
      if (!isOnline) {
        setError('Unable to connect to the server. Please check your internet connection and refresh the page.')
      }
    }
    
    initializeSystems()
    
    // Cleanup function
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort()
      }
      if (retryTimeoutRef.current) {
        clearTimeout(retryTimeoutRef.current)
      }
    }
  }, [])

  // Robust fetch with retry logic
  const robustFetch = async (url, options = {}, retryAttempt = 0) => {
    try {
      // Create new AbortController for this request
      if (abortControllerRef.current) {
        abortControllerRef.current.abort()
      }
      abortControllerRef.current = new AbortController()
      
      const timeoutId = setTimeout(() => {
        abortControllerRef.current.abort()
      }, NETWORK_TIMEOUT)
      
      const response = await fetch(url, {
        ...options,
        signal: abortControllerRef.current.signal,
        headers: {
          'Content-Type': 'application/json',
          ...options.headers
        }
      })
      
      clearTimeout(timeoutId)
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      
      return await response.json()
    } catch (error) {
      if (error.name === 'AbortError') {
        throw new Error('Request timed out. Please check your connection and try again.')
      }
      
      if (retryAttempt < MAX_RETRY_ATTEMPTS - 1) {
        console.log(`Request failed (attempt ${retryAttempt + 1}), retrying in ${RETRY_DELAY * (retryAttempt + 1)}ms...`)
        setIsRetrying(true)
        
        await new Promise(resolve => {
          retryTimeoutRef.current = setTimeout(resolve, RETRY_DELAY * (retryAttempt + 1))
        })
        
        setIsRetrying(false)
        return await robustFetch(url, options, retryAttempt + 1)
      }
      
      throw error
    }
  }

  const handleChange = (e) => {
    const { name, value } = e.target
    setFormData(prev => ({
      ...prev,
      [name]: value
    }))
    
    // Clear field-specific validation error
    if (validationErrors[name]) {
      setValidationErrors(prev => ({
        ...prev,
        [name]: null
      }))
    }
    
    // Clear general error
    if (error) {
      setError(null)
    }
  }

  const validateForm = () => {
    const errors = {}
    
    if (!formData.name.trim()) errors.name = 'Name is required'
    else if (formData.name.trim().length < 2) errors.name = 'Name must be at least 2 characters'
    
    if (!formData.email.trim()) errors.email = 'Email is required'
    else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email)) errors.email = 'Invalid email format'
    
    if (!formData.phone.trim()) errors.phone = 'Phone number is required'
    else if (!/^[+]?[\d\s\-\(\)]{10,15}$/.test(formData.phone)) errors.phone = 'Invalid phone number format'
    
    if (!formData.college.trim()) errors.college = 'College is required'
    else if (formData.college.trim().length < 2) errors.college = 'College name must be at least 2 characters'
    
    if (!formData.year) errors.year = 'Year is required'
    
    setValidationErrors(errors)
    return Object.keys(errors).length === 0
  }

  const resetForm = () => {
    setFormData({ name: '', email: '', phone: '', college: '', year: '' })
    setError(null)
    setValidationErrors({})
    setPaymentStatus(null)
    setIsProcessing(false)
    setRegistrationData(null)
  }

  const handleSubmit = async (e) => {
    e.preventDefault()
    
    // Clear previous errors
    setError(null)
    setValidationErrors({})
    
    // First, check network connectivity
    const isOnline = await checkNetworkStatus()
    if (!isOnline) {
      setError('No internet connection. Please check your network and try again.')
      return
    }
    
    // Validate form
    if (!validateForm()) {
      return
    }
    
    setIsProcessing(true)
    setPaymentStatus('creating_order')
    
    try {
      // Create Razorpay order
      const response = await fetch(buildApiUrl(API_ENDPOINTS.CREATE_ORDER), {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(formData)
      })

      if (!response.ok) {
        const errorText = await response.text()
        throw new Error(`HTTP ${response.status}: ${errorText || 'Server error'}`)
      }

      const result = await response.json()

      if (!result.success) {
        // Handle validation errors from server
        if (result.errors && Array.isArray(result.errors)) {
          const serverErrors = {}
          result.errors.forEach(err => {
            if (err.path) serverErrors[err.path] = err.msg
          })
          setValidationErrors(serverErrors)
        }
        throw new Error(result.message || 'Failed to create order')
      }

      setPaymentStatus('opening_payment')

      // Check if Razorpay is loaded
      if (!window.Razorpay) {
        throw new Error('Payment system is not available. Please refresh the page and ensure you have a stable internet connection.')
      }

      console.log('Initializing payment with Razorpay...')
      console.log('Order details:', { orderId: result.orderId, amount: result.amount })

      // Initialize Razorpay payment
      const options = {
        key: config.RAZORPAY_KEY_ID,
        amount: result.amount,
        currency: result.currency,
        name: 'Event Registration',
        description: 'Registration for our amazing event',
        order_id: result.orderId,
        timeout: 300, // 5 minutes timeout
        handler: async function (response) {
          setPaymentStatus('verifying_payment')
          
          // Payment successful, verify payment
          try {
            const verifyResponse = await fetch(buildApiUrl(API_ENDPOINTS.VERIFY_PAYMENT), {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                razorpay_order_id: response.razorpay_order_id,
                razorpay_payment_id: response.razorpay_payment_id,
                razorpay_signature: response.razorpay_signature,
                registrationId: result.registrationId
              })
            })

            if (!verifyResponse.ok) {
              throw new Error(`HTTP ${verifyResponse.status}: Verification failed`)
            }

            const verifyResult = await verifyResponse.json()

            if (verifyResult.success) {
              console.log('Payment verified:', verifyResult.data)
              setRegistrationData(verifyResult.data)
              setPaymentStatus('completed')
              setIsSubmitted(true)
            } else {
              throw new Error(verifyResult.message || 'Payment verification failed')
            }
          } catch (verificationError) {
            console.error('Payment verification error:', verificationError)
            setPaymentStatus('verification_failed')
            setError(`Payment verification failed: ${verificationError.message}. Your payment may have been processed. Please contact support with payment ID: ${response.razorpay_payment_id}`)
          } finally {
            setIsProcessing(false)
          }
        },
        prefill: {
          name: formData.name,
          email: formData.email,
          contact: formData.phone
        },
        notes: {
          college: formData.college,
          year: formData.year
        },
        theme: {
          color: '#2563eb'
        },
        modal: {
          ondismiss: function() {
            console.log('Payment cancelled by user')
            setPaymentStatus('cancelled')
            setIsProcessing(false)
            setError('Payment was cancelled. Please try again to complete your registration.')
          },
          escape: true,
          backdropclose: false
        }
      }

      const rzp = new window.Razorpay(options)
      
      rzp.on('payment.failed', function (response) {
        console.error('Payment failed:', response.error)
        setPaymentStatus('failed')
        setIsProcessing(false)
        
        let errorMessage = 'Payment failed. '
        
        // Handle specific Razorpay error codes
        switch(response.error.code) {
          case 'BAD_REQUEST_ERROR':
            errorMessage += 'Please check your payment details and try again.'
            break
          case 'GATEWAY_ERROR':
            errorMessage += 'Payment gateway error. Please try a different payment method.'
            break
          case 'NETWORK_ERROR':
            errorMessage += 'Network connectivity issue. Please check your internet connection and try again.'
            break
          case 'SERVER_ERROR':
            errorMessage += 'Payment service is temporarily unavailable. Please try again in a few minutes.'
            break
          case 'INVALID_REQUEST_ERROR':
            errorMessage += 'Invalid payment request. Please refresh the page and try again.'
            break
          default:
            errorMessage += response.error.description || 'Please try again or contact support.'
        }
        
        // Add additional context for common issues
        if (response.error.description && response.error.description.includes('network')) {
          errorMessage += ' If this persists, try using a different network or device.'
        }
        
        setError(errorMessage)
      })
      
      // Add error handling for opening payment modal
      try {
        rzp.open()
        console.log('Payment modal opened successfully')
      } catch (openError) {
        console.error('Failed to open payment modal:', openError)
        setPaymentStatus('failed')
        setIsProcessing(false)
        setError('Unable to open payment window. Please check if popups are blocked and try again.')
        return
      }

    } catch (error) {
      console.error('Registration error:', error)
      setIsProcessing(false)
      setPaymentStatus('error')
      
      // Handle different types of errors with more specific messages
      let errorMessage = error.message
      
      if (error.name === 'TypeError' && error.message.includes('fetch')) {
        errorMessage = 'Unable to connect to the server. Please check your internet connection and try again.'
      } else if (error.message.includes('NetworkError') || error.message.includes('ERR_NETWORK')) {
        errorMessage = 'Network connection problem. Please check your internet connection and try again.'
      } else if (error.message.includes('already registered')) {
        errorMessage = 'This email is already registered for the event. Please use a different email or contact support.'
      } else if (error.message.includes('Payment system')) {
        errorMessage = 'Payment service is currently unavailable. Please try again in a few minutes or contact support.'
      } else if (error.message.includes('timeout')) {
        errorMessage = 'Request timed out. Please check your connection and try again.'
      } else if (!errorMessage || errorMessage === 'Failed to fetch') {
        errorMessage = 'Registration failed. Please check your internet connection and try again.'
      }
      
      setError(errorMessage + ' If the problem persists, please contact our support team.')
    }
  }

  const isFormValid = formData.name.trim() && 
                      formData.email.trim() && 
                      formData.phone.trim() && 
                      formData.college.trim() && 
                      formData.year.trim() &&
                      Object.keys(validationErrors).length === 0

  if (isSubmitted) {
    return (
      <div className="min-h-screen flex justify-center items-center bg-black px-4">
        <div className="w-full max-w-lg bg-[#1a1a1a] rounded-2xl p-8 border border-gray-700">
          <div className="text-center">
            <div className="w-16 h-16 bg-green-600 rounded-full flex items-center justify-center mx-auto mb-4">
              <svg className="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M5 13l4 4L19 7"></path>
              </svg>
            </div>
            <h2 className="text-2xl font-bold text-white mb-2">
              Registration Successful!
            </h2>
            <p className="text-gray-400 mb-6 text-sm">
              Thank you for registering. Check your email for confirmation.
            </p>
            
            {registrationData && (
              <div className="bg-[#262626] rounded-lg p-4 mb-6 text-left border border-gray-600">
                <h3 className="font-semibold text-purple-400 mb-3 text-sm">
                  Registration Details
                </h3>
                <div className="space-y-2 text-sm">
                  <div className="flex justify-between">
                    <span className="text-gray-400">Name</span>
                    <span className="text-white">{registrationData.name}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-400">Email</span>
                    <span className="text-white">{registrationData.email}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-400">College</span>
                    <span className="text-white">{registrationData.college}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-400">Year</span>
                    <span className="text-white">{registrationData.year}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-400">Amount Paid</span>
                    <span className="text-green-400 font-semibold">₹{registrationData.amount}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-400">Registration ID</span>
                    <span className="text-purple-400 font-mono text-xs">{registrationData.id}</span>
                  </div>
                </div>
              </div>
            )}
            
            <button 
              onClick={() => {
                setIsSubmitted(false)
                resetForm()
              }}
              className="w-full bg-purple-600 hover:bg-purple-700 text-white py-3 rounded-full text-base font-semibold"
            >
              Register Another Person
            </button>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen flex justify-center items-center bg-black px-4">
      <div className="w-full max-w-lg">
        <form onSubmit={handleSubmit} className="bg-[#1a1a1a] rounded-2xl p-8 border border-gray-700">
          <div className="flex justify-center mb-4">
            <img src="/ACES_LOGO-.png" alt="ACES Logo" className="h-16 w-auto" />
          </div>
          <h2 className="text-3xl font-bold text-center text-white mb-1">
            Registration for
          </h2>
          <h3 className="text-xl font-semibold text-center text-purple-400 mb-6">
            ACD 2026
          </h3>

          {/* Network Status Indicator */}
          {networkStatus === 'offline' && (
            <div className="bg-yellow-900/30 border border-yellow-600 rounded-lg p-3 mb-4">
              <p className="text-yellow-300 text-sm">⚠️ Connection issue. Please check your internet.</p>
            </div>
          )}

          {/* Error Display */}
          {error && (
            <div className="bg-red-900/30 border border-red-600 rounded-lg p-3 mb-4">
              <p className="text-red-300 text-sm">❌ {error}</p>
            </div>
          )}
          
          {/* Payment Status Display */}
          {paymentStatus && paymentStatus !== 'completed' && paymentStatus !== 'error' && (
            <div className="bg-blue-900/30 border border-blue-600 rounded-lg p-3 mb-4">
              <div className="flex items-center gap-2">
                <div className="animate-spin rounded-full h-4 w-4 border-2 border-blue-400 border-t-transparent"></div>
                <p className="text-blue-300 text-sm">
                  {paymentStatus === 'creating_order' && 'Creating payment order...'}
                  {paymentStatus === 'opening_payment' && 'Opening payment gateway...'}
                  {paymentStatus === 'verifying_payment' && 'Verifying payment...'}
                  {paymentStatus === 'cancelled' && 'Payment cancelled'}
                  {paymentStatus === 'failed' && 'Payment failed'}
                </p>
              </div>
            </div>
          )}

          <div className="space-y-4">
            <input
              type="text"
              name="name"
              value={formData.name}
              onChange={handleChange}
              placeholder="Full Name"
              required
              className="w-full bg-[#262626] text-white px-4 py-3 rounded-lg border border-gray-600"
            />
            {validationErrors.name && (
              <p className="text-red-400 text-xs mt-1">⚠ {validationErrors.name}</p>
            )}

            <input
              type="email"
              name="email"
              value={formData.email}
              onChange={handleChange}
              placeholder="Email"
              required
              className="w-full bg-[#262626] text-white px-4 py-3 rounded-lg border border-gray-600"
            />
            {validationErrors.email && (
              <p className="text-red-400 text-xs mt-1">⚠ {validationErrors.email}</p>
            )}

            <input
              type="tel"
              name="phone"
              value={formData.phone}
              onChange={handleChange}
              placeholder="Phone Number"
              required
              className="w-full bg-[#262626] text-white px-4 py-3 rounded-lg border border-gray-600"
            />
            {validationErrors.phone && (
              <p className="text-red-400 text-xs mt-1">⚠ {validationErrors.phone}</p>
            )}

            <input
              type="text"
              name="college"
              value={formData.college}
              onChange={handleChange}
              placeholder="College / Organization"
              required
              className="w-full bg-[#262626] text-white px-4 py-3 rounded-lg border border-gray-600"
            />
            {validationErrors.college && (
              <p className="text-red-400 text-xs mt-1">⚠ {validationErrors.college}</p>
            )}

            <select
              name="year"
              value={formData.year}
              onChange={handleChange}
              required
              className="w-full bg-[#262626] text-white px-4 py-3 rounded-lg border border-gray-600"
            >
              <option value="">Select Year</option>
              <option>1st Year</option>
              <option>2nd Year</option>
              <option>3rd Year</option>
              <option>4th Year</option>
              <option>Graduate</option>
              <option>Post Graduate</option>
            </select>
            {validationErrors.year && (
              <p className="text-red-400 text-xs mt-1">⚠ {validationErrors.year}</p>
            )}
          </div>

          <button
            disabled={!isFormValid || isProcessing}
            className="w-full mt-6 bg-purple-600 hover:bg-purple-700 text-white py-3 rounded-full text-lg"
          >
            {isProcessing ? 'Processing...' : 'Proceed to Payment ₹199'}
          </button>

          <p className="text-center text-sm text-gray-400 mt-4">
            Secure payment powered by Razorpay
          </p>
        </form>
      </div>
    </div>
  )
}

export default EventForm